class Point(xc, yc: Integer) is {
    static auto next : Integer;
    auto x, auto y: Integer;
    auto name : String;
    hasClone : Integer;
    index : Integer;
    /* la valeur du champ ci-dessous est indefinie si hasClone vaut 0.
    * Le probleme est qu'on n'a pas l'equivalent de NULL (du bon type)
    */
    clone : Point;

  def Point(xc, yc: Integer) is {
    this.x := xc; this.y := yc;
    this.index := Point.incr();
    this.name  := "Point_" & this.index.toString();
    this.hasClone := 0;
  }

  def static initPoint() is { next := 1; }

  def static get() : Integer := next
  
  def static incr() : Integer is {
    this.next := this.next + 1; result := this.next;
  }

  def setName(newName: String) is { this.name := newName; }

  def isCloned() : Integer := this.hasClone <> 0

  def move(dx, dy: Integer, verbose: Integer) : Point is {
      this.x := this.x + dx;
      this.y := this.y() + dy; /* usage de la methode definie automatiquement */
      if verbose then { this.print(verbose); } else {}
      /* pseudo variable 'result' dans laquelle, par convention, on laisse
       * la valeur de retour d'une fonction qui a un type de retour.
       * On aurait pu ecrire aussi:  return this;
       */
      result := this;
  }

  def print(verbose : Integer) is {
      if verbose then "Inside Point::print".println(); else { }
      this.name.print();
      /* & est l'operateur de concatenation de chaines: on construit une
       * chaine au vol, avant de l'imprimer
       */
      ( "= (" & this.x.toString() & ", " & this.y.toString() & ")" ).println();
  }


  def clone() : Point is
  { p : Point;
    is
    p = new Point(this.x, this.y);
    this.hasClone := 1;
   /* On memorise uniquement notre dernier clone. On pourrait chainer
    * tous nos clones. On modifie le nom du clone pour garder sa provenance.
    */
    this.clone := p;
    p.name = p.name & "[" & this.name & "]";
    result := p;
  }


   /* imprime le clone de cet objet, s'il existe, ainsi que recursivement
   * les clones de ce dernier.
   */
  def allClones () is {
    if this.hasClone <> 0 then { this.clone.print(1); this.clone.allClones(); }
    else { }
  }


  def egal(p: Point) : Integer is {
    b1, b2: Integer;
    is
    b1 := p.x - this.x;  b2 := p.y - this.y;
    result := 0;
    if b1 then { } else { result := b2 = 0; }
  }

} /* Fin de la classe Point */


{
}

