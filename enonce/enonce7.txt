class Point(xc, yc: Integer) is {
    static auto next : Integer;
    auto x, auto y: Integer;
    auto name : String;
    index : Integer;

  def Point(xc, yc: Integer) is {
    this.x := xc; this.y := yc;
    this.index := Point.incr();
    this.name  := "Point_" & this.index.toString();
  }

  def static initPoint() is { next := 1; }

  def static get() : Integer := next
  
  def static incr() : Integer is {
    this.next := this.next + 1; result := this.next;
  }

  def move(dx, dy: Integer, verbose: Integer) : Point is {
      this.x := this.x + dx;
      this.y := this.y() + dy; /* usage de la methode definie automatiquement */
      if verbose then { this.print(verbose); } else {}
      /* pseudo variable 'result' dans laquelle, par convention, on laisse
       * la valeur de retour d'une fonction qui a un type de retour.
       * On aurait pu ecrire aussi:  return this;
       */
      result := this;
  }

  def setName(newName: String) is { this.name := newName; }

  def print(verbose : Integer) is {
      if verbose then "Inside Point::print".println(); else { }
      this.name.print();
      /* & est l'operateur de concatenation de chaines: on construit une
       * chaine au vol, avant de l'imprimer
       */
      ( "= (" & this.x.toString() & ", " & this.y.toString() & ")" ).println();
  }

}


{
}

